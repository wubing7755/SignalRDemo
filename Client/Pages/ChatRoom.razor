@page "/chat"
@using SignalRDemo.Client.Services
@using SignalRDemo.Shared.Models
@using Microsoft.AspNetCore.Components
@inject ChatService ChatService
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

<div class="chat-container">
    <!-- å¤´éƒ¨ -->
    <div class="chat-header">
        <div class="chat-title">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
            </svg>
            å®æ—¶èŠå¤©å®¤
        </div>
        <div class="connection-info">
            <span class="status-badge @(ChatService.IsConnected ? "connected" : "disconnected")">
                <span class="status-dot"></span>
                @(ChatService.IsConnected ? "å·²è¿æ¥" : "æœªè¿æ¥")
            </span>
            <span class="current-user">
                å½“å‰ç”¨æˆ·: <strong>@ChatService.GetCurrentUser()</strong>
            </span>
        </div>
    </div>

    <!-- èŠå¤©ä¸»ä½“ -->
    <div class="chat-body">
        <!-- æ¶ˆæ¯åŒºåŸŸ -->
        <div class="chat-messages-wrapper">
            <div class="chat-messages" @ref="_messagesContainer">
                @if (_messages.Count == 0)
                {
                    <div class="empty-state">
                        <div class="empty-icon">ğŸ’¬</div>
                        <div class="empty-title">è¿˜æ²¡æœ‰æ¶ˆæ¯</div>
                        <div class="empty-subtitle">å‘é€ç¬¬ä¸€æ¡æ¶ˆæ¯å¼€å§‹èŠå¤©å§ï¼</div>
                    </div>
                }
                else
                {
                    @foreach (var message in _messages)
                    {
                        var isOwnMessage = message.User == ChatService.GetCurrentUser();
                        <div class="message @(isOwnMessage ? "own-message" : "other-message")">
                            <div class="message-avatar" style="background: @GetUserColor(message.User)">
                                @GetUserInitial(message.User)
                            </div>
                            <div class="message-content">
                                <div class="message-header">
                                    <span class="message-user">@message.User</span>
                                    <span class="message-time">@FormatTime(message.Timestamp)</span>
                                </div>
                                <div class="message-bubble">
                                    @message.Message
                                </div>
                            </div>
                        </div>
                    }
                }
                <div @ref="_messagesEnd"></div>
            </div>

            <!-- è¾“å…¥åŒºåŸŸ -->
            <div class="message-input-area">
                <div class="input-wrapper">
                    <input @bind="_newMessage" 
                           @bind:event="oninput" 
                           @onkeypress="HandleKeyPress"
                           placeholder="è¾“å…¥æ¶ˆæ¯..." 
                           class="message-input"
                           disabled="@(!ChatService.IsConnected)" />
                    <button @onclick="SendMessage" 
                            class="send-button" 
                            disabled="@(string.IsNullOrWhiteSpace(_newMessage) || !ChatService.IsConnected)"
                            title="å‘é€æ¶ˆæ¯">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- ç”¨æˆ·åˆ—è¡¨é¢æ¿ -->
        <div class="user-panel">
            <div class="user-panel-header">
                <div class="user-panel-title">
                    åœ¨çº¿ç”¨æˆ·
                    <span class="user-count">@_connectedUsers.Count</span>
                </div>
            </div>
            <div class="user-list">
                @foreach (var user in _connectedUsers)
                {
                    <div class="user-item">
                        <div class="user-item-avatar" style="background: @GetUserColor(user)">
                            @GetUserInitial(user)
                        </div>
                        <div class="user-item-info">
                            <div class="user-item-name">@user</div>
                            <div class="user-item-status">
                                <span class="online-dot"></span>
                                åœ¨çº¿
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    private List<ChatMessage> _messages = new();
    private List<string> _connectedUsers = new();
    private string _newMessage = string.Empty;
    private ElementReference _messagesContainer;
    private ElementReference _messagesEnd;
    private bool _shouldScrollToBottom;

    // é¢„å®šä¹‰çš„ç”¨æˆ·é¢œè‰²
    private static readonly string[] UserColors = new[]
    {
        "#667eea", "#764ba2", "#f093fb", "#f5576c",
        "#4facfe", "#00f2fe", "#43e97b", "#38f9d7",
        "#fa709a", "#fee140", "#30cfd0", "#330867",
        "#a8edea", "#fed6e3", "#ff9a9e", "#fecfef"
    };

    protected override async Task OnInitializedAsync()
    {
        await InitializeChatService();
        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScrollToBottom)
        {
            _shouldScrollToBottom = false;
            await ScrollToBottomAsync();
        }
    }

    private async Task InitializeChatService()
    {
        try
        {
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var hubUrl = $"{baseUrl}/chathub";
            Console.WriteLine($"æ­£åœ¨è¿æ¥åˆ°SignalR Hub: {hubUrl}");

            await ChatService.InitializeAsync(hubUrl);
            Console.WriteLine($"SignalRè¿æ¥çŠ¶æ€: {ChatService.IsConnected}");

            ChatService.MessageReceived += OnMessageReceived;
            ChatService.UserConnected += OnUserConnected;
            ChatService.UserDisconnected += OnUserDisconnected;
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalRè¿æ¥å¤±è´¥: {ex.Message}");
            Console.WriteLine($"å®Œæ•´é”™è¯¯: {ex}");
        }
    }

    private void OnMessageReceived(ChatMessage message)
    {
        _messages.Add(message);
        _shouldScrollToBottom = true;
        InvokeAsync(StateHasChanged);
    }

    private void OnUserConnected(string connectionId)
    {
        if (!_connectedUsers.Contains(connectionId))
        {
            _connectedUsers.Add(connectionId);
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnUserDisconnected(string connectionId)
    {
        _connectedUsers.Remove(connectionId);
        InvokeAsync(StateHasChanged);
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(_newMessage))
        {
            await ChatService.SendMessageAsync(_newMessage);
            _newMessage = string.Empty;
            _shouldScrollToBottom = true;
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(_newMessage))
        {
            await SendMessage();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await InvokeAsync(async () =>
            {
                await _messagesEnd.FocusAsync();
            });
        }
        catch
        {
            // å¦‚æœ FocusAsync å¤±è´¥ï¼Œå¿½ç•¥é”™è¯¯
        }
    }

    /// <summary>
    /// è·å–ç”¨æˆ·é¦–å­—æ¯
    /// </summary>
    private string GetUserInitial(string userName)
    {
        if (string.IsNullOrEmpty(userName))
            return "?";
        
        // å–ç¬¬ä¸€ä¸ªå­—æ¯æˆ–å­—ç¬¦
        var firstChar = userName.Trim().FirstOrDefault();
        return char.ToUpper(firstChar).ToString();
    }

    /// <summary>
    /// è·å–ç”¨æˆ·å¯¹åº”çš„é¢œè‰²ï¼ˆåŸºäºç”¨æˆ·åå“ˆå¸Œï¼‰
    /// </summary>
    private string GetUserColor(string userName)
    {
        if (string.IsNullOrEmpty(userName))
            return UserColors[0];
        
        // ä½¿ç”¨ç”¨æˆ·åå“ˆå¸Œæ¥é€‰æ‹©é¢œè‰²ï¼Œç¡®ä¿åŒä¸€ç”¨æˆ·å§‹ç»ˆæ˜¾ç¤ºç›¸åŒé¢œè‰²
        var hash = userName.GetHashCode();
        var index = Math.Abs(hash) % UserColors.Length;
        return UserColors[index];
    }

    /// <summary>
    /// æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
    /// </summary>
    private string FormatTime(DateTime timestamp)
    {
        var localTime = timestamp.ToLocalTime();
        var now = DateTime.Now;
        
        if (localTime.Date == now.Date)
        {
            return localTime.ToString("HH:mm");
        }
        else if (localTime.Date == now.AddDays(-1).Date)
        {
            return $"æ˜¨å¤© {localTime:HH:mm}";
        }
        else
        {
            return localTime.ToString("MM-dd HH:mm");
        }
    }

    public async ValueTask DisposeAsync()
    {
        ChatService.MessageReceived -= OnMessageReceived;
        ChatService.UserConnected -= OnUserConnected;
        ChatService.UserDisconnected -= OnUserDisconnected;
        await ChatService.DisposeAsync();
    }
}
